var bunyan = require('bunyan');
var util = require('util');
var path = require('path');
var rootLogger = null;
var logger_key = '__xlog__';
var replaceConsole = false;
var projectDir = null;
var pathCache = {};
if ( !console.debug ) console.debug = console.log;
var LoggerWrapper = function(fields){
  this.fields = fields;
  this.logger = rootLogger;
  this.updateMethods();
};

var ConsoleLoggerWrapper = function(){
  this.logger = console;
  this.updateMethods();
};

var logMethods = ["info", "error", "warn", "trace", "debug"];
var LoggerWrapperClass = LoggerWrapper;

function mergeObject(){
  var v = {};
  var empty = true;
  for (var i = 0;i < arguments.length; ++ i ) {
    var arg = arguments[i];
    if ( arg ) {
      empty = false;
      for ( var key in arg ){
        v[key] = arg[key];
      }
    }
  }
  if ( empty ) return null;
  return v;
};

function isObject(v){
  return v!=null && typeof(v) == 'object' && !Array.isArray(v);
}

function isString(v){
  return (typeof(v) == 'string' || v instanceof String);
}

function makeFunc(func, logger, fields){
  return function(){
    if ( isObject(arguments[0]) ) {
      var arg0 = mergeObject(fields, arguments[0]);
      arguments[0] = arg0;
      return func.apply(logger, arguments);
    }
    else {
      var args = [fields];
      args = args.concat.apply(args, arguments);
      return func.apply(logger, args);
    }
  }
}

LoggerWrapper.prototype = {
  updateMethods: function(){
    this.info = makeFunc(this.logger.info, this.logger, this.fields);
    this.warn = makeFunc(this.logger.warn, this.logger, this.fields);
    this.error = makeFunc(this.logger.error, this.logger, this.fields);
    this.debug = makeFunc(this.logger.debug, this.logger, this.fields);
    this.trace = makeFunc(this.logger.trace, this.logger, this.fields);
    this.log = this.info;
    if ( replaceConsole ) {
      console.log = this.log;
      console.info = this.info;
      console.error = this.error;
      console.trace = this.trace;
      console.warn = this.warn;
      console.debug = this.debug;
    }
  },
  get: function(fields){
    var newFields = mergeObject(this.fields, fields);
    return new LoggerWrapper(newFields);
  }
};

ConsoleLoggerWrapper.prototype = {
  updateMethods: function(){
    this.info = console.info;
    this.warn = console.warn;
    this.error = console.error;
    this.debug = console.debug;
    this.trace = console.trace;
    this.log = console.info;
  },
  get: function(fields){
    return this;
  }
};

function initialize(){
  if ( rootLogger != null ) {
    throw new Error('logger already configured!');
  }
  var config = arguments[0];
  if ( config.projectDir ) {
    projectDir = config.projectDir;
    delete config.projectDir;
  }
  var loggerConfig = mergeObject({
    name:'system',
    serializers: bunyan.stdSerializers
  }, config);
  bunyan.stdSerializers.req = function req(req) {
    if (!req || !req.connection)
      return req;
    return {
      method: req.method,
      url: req.url,
      remoteAddress: req.connection.remoteAddress,
      remotePort: req.connection.remotePort
    };
  };
  bunyan.stdSerializers.module = function(mod) {
    if (!mod || !mod.filename)
      return mod;
    var f = pathCache[mod.filename];
    if ( !f ){
      if ( projectDir) {
        f = mod.filename.substr(projectDir.length+1);
      }
      else {
        f = mod.filename;
      }
      pathCache[mod.filename] = f;
    }
    return f;
  };
  if ( loggerConfig.replaceConsole != null ) {
    replaceConsole = loggerConfig.replaceConsole;
    delete loggerConfig.replaceConsole;
  }
  rootLogger = bunyan.createLogger.apply(bunyan, [loggerConfig]);
  if ( replaceConsole ) {
    function makeConsoleFunc(key, origFunc){
      return function(){
        var logger = global[logger_key];
        if ( logger ) return logger[key].apply(logger, arguments);
        else return origFunc.apply(console, arguments);
      }
    }
    for ( var i = 0; i < logMethods.length; ++i ) {
      var name = logMethods[i];
      var origFunc = console[name];
      console[name] = makeConsoleFunc(name, origFunc);
    }
    console.log = console.info;
  }
  for ( var i = 0; i < logMethods.length; ++i ) {
    var name = logMethods[i];
    this[name] = rootLogger[name].bind(rootLogger);
  }
  this.log = this.info;
}

// Seems there are some problems when using cassandra driver after replaced bind, disable this for now
if ( false && !Function.prototype.bind.bindLogger ) {
  var oldBind = Function.prototype.bind;
  Function.prototype.bind = function bindLogger() {
    var logger = global[logger_key];
    var func = oldBind.apply(this, arguments);
    var newFunc = function(){
      var oldLogger = global[logger_key];
      global[logger_key] = logger;
      try {
        func.apply(null, arguments);
      }
      finally {
        global[logger_key] = oldLogger;
      }
    };
    return newFunc;
  };
  Function.prototype.bind.bindLogger = true;
}

Function.prototype.bindLogger = function(){
  var func = this;
  var logger = null;
  var obj = null;
  var len = arguments.length;
  if ( len == 0 ) {
    logger = global[logger_key];
    obj = null;
    msg = null;
  }
  else {
    for ( var i = 0; i < arguments.length; ++ i ) {
      if ( arguments[i] instanceof LoggerWrapperClass ) {
        logger = arguments[i];
      }
      else if ( isString(arguments[i]) ) {
        msg = arguments[i];
      }
      else if ( isObject(arguments[i]) ){
        obj = arguments[i];
      }
    }
    if ( !logger ) logger = global[logger_key];
  }
  var msg = msg || func.name;
  return function(){
    var oldLogger = global[logger_key];
    global[logger_key] = logger;
    var name = func.name;
    if ( msg ) logger.trace('=> %s', msg);
    try {
      return func.apply(obj, arguments);
    }
    finally{
      if ( msg ) logger.trace('<= %s', msg);
      global[logger_key] = oldLogger;
    }
  }
};

function createLogger(){
  var args = [].concat.apply([null], arguments);
  var logger = new (Function.prototype.bind.apply(LoggerWrapperClass, args));
  return logger;
}

getLogger = function(fields){
  var logger = global[logger_key];
  var newLogger = null;
  if ( logger ) {
    if ( !fields ) return logger;
    var newFields = mergeObject(logger.fields, fields);
    var newLogger = new LoggerWrapperClass(newFields);
  }
  else {
    var newLogger = new LoggerWrapperClass(fields);
  }
  global[logger_key] = newLogger;
  return newLogger;
};

module.exports = {
  initialize: initialize,
  get: getLogger,
  level: function(level){
    if( rootLogger ) {
      rootLogger.level(level);
      rootLogger.warn(`改变警告级别为${level}`);
    }
  },
  raw: function(){
    return rootLogger;
  }
};
