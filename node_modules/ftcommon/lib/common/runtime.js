var os = require('os');
var Runtime = function(args){
  this.config = {};
  if ( args && args.adapter ) {
    this.adapter = args.adapter;
  }
};
var URL = null;
var QS = null;
var RUNTIME_URL = '/runtime/';
const CHANGED_EVENT = 'changed';
const TYPE_CONST = 1;
Runtime.prototype = {
  // onChange(value, done);
  registerConstant: function(key, defaultValue, meta) {
    this.config[key] = {value: defaultValue, type:TYPE_CONST, meta: meta};
  },

  register: function(key, defaultValue, onChange, meta){
    var item = {
      key: key,
      value: defaultValue,
      onChange: onChange,
      meta: meta
    };
    this.config[key] = item;
  },

  start: function(done){
    if ( this.adapter ) {
      this.adapter.attach(function(err){
        if ( err ) done(err);
        else {
          this.adapter.on(CHANGED_EVENT, function(args){
            var item = this.config[args.key];
						var oldValue =item.value;
						this._notifyChanged(item, oldValue, args.newValue);
          }.bind(this));
          this._start(done);
        }
      }.bind(this));
    }
    else {
      this._start(done);
    }
  },

  _start: function(done){
    var errs = {};
    var errCount = 0;
    var count = 0;
    var total = 0;
    for ( var key in this.config ) {
      var item = this.config[key];
      var oldValue = item.value;
      var value = oldValue;
      if ( item.onChange ) {
        total ++;
        this._notifyChanged(item, oldValue, value, function(key, err){
          count ++;
          if ( err ) {
            errs[key] = err;
            errCount++;
          }
          if ( count >= total ) {
            done(errCount>0?errs:null);
          }
        }.bind(this, key));
      }
    }
  },

  keys: function() {
    return Object.keys(this.config);
  },

  getAll: function(){
    var items = {};
    for (var key in this.config){
      var item = this.config[key];
      items[key] = item.value;
    }
    return items;
  },

  isConst: function(key){
    return this.config[key].type === TYPE_CONST;
  },

  get: function(key, fn){
    if ( fn == null ){
      return this.config[key].value;
    }
    else {
      fn(this.config[key].value);
    }
  },

  notifyChanged:function(item, oldValue, value, done){
    if ( this.adapter ) {
      this.adapter.emit(CHANGED_EVENT, {
        key: item.key,
        oldValue: oldValue,
        newValue : value
      }, done);
			//console.log('changed with adapter');
    }
    else {
      this._notifyChanged(item, oldValue, value, done);
    }
  },

  _notifyChanged:function(item, oldValue, value, done){
		//console.log('_notifyChanged', oldValue, value);
		item.value = value;
    if ( item.onChange) {
      setImmediate(function(value, oldValue){
        item.onChange(value, function(err){
          done && done(err, value, oldValue);
        });
      }, value, oldValue);
    }
    else { // no onChange callback defined
      done && setImmediate(done, null, value, oldValue);
    }
  },

  set: function(key, value, done){
    var item = this.config[key];
    if ( !item ) {
      throw new Error(`Not registered runtime entry [${key}]`);
    }
    if ( item.type === TYPE_CONST ) {
      throw new Error(`Trying to set constant entry [${key}]`);
    }
    var oldValue = item.value;
    this.notifyChanged(item, oldValue, value, done);
  },

  attach: function(srv, path){
    URL = require('url');
    QS = require('querystring');
    if ( path && path.substr(path.length-1)=='/'){
      RUNTIME_URL = path;
    }
    var url = RUNTIME_URL;
    var evs = srv.listeners('request').slice(0);
    var self = this;
    srv.removeAllListeners('request');
    srv.on('request', function(req, res) {
      if (0 == req.url.indexOf(url)) {
        self.serve(req, res);
      } else {
        for (var i = 0; i < evs.length; i++) {
          evs[i].call(srv, req, res);
        }
      }
    });
  },

  serve: function(req, res) {
    var base = RUNTIME_URL;
    var url = URL.parse(req.url);
    res.setHeader('Content-Type', 'text/html;charset=utf-8');
    if ( url && url.pathname == base+'set' ) {
      var qs = url.query?QS.parse(url.query):{};
      var total = 0;
      var count = 0;
      var msgs = [];
      function handleResult(key, value, err){
        count ++;
        var msg;
        if ( err ) msg = `<font color="red">设置${key}=${value}失败</font>`;
        else msg = `成功设置${key}=${value}`;
        msgs.push(`<li>${msg}</li>`);
        if ( count >= total ) {
          res.end(`<!DOCTYPE html>
            <html>
              <head>
                <meta http-equiv="refresh" content="3; url=${base}" />
              </head>
              <body>
                <ol>设置结果：
                  ${msgs.join('\n')}
                </ol>
              </body>
            </html>
          `);
        }
      };
      for ( var key in qs ) {
        var item = this.config[key];
        if ( !item || !item.meta ) continue;
        var value = qs[key];
        var meta = item.meta;
        if ( value == item.value ) continue;
        total ++;
        if ( meta.type == 'enum' ) {
          var found = false;
          for(var i = 0; i < meta.options.length; ++i ) {
            var option = meta.options[i];
            if ( option.value == value ) {
              found = true;
              break;
            }
          }
          if ( found )
            this.set(key, value, handleResult.bind(null, key, value));
          else
            handleResult(key, value, new Error('Invalid value!'));
        }
        else if ( meta.type == 'bool' ) {
          value = (value == "true" || value == true);
          this.set(key, value, handleResult.bind(null, key, value));
        }
        else if ( meta.type == 'number' || meta.type == 'int' || meta.type == 'long' ){
          try {
            value = Number.parseFlota(value);
            this.set(key, value, handleResult.bind(null, key, value));
          }
          catch(e) {
            handleResult(key, value, e);
          }
        }
        else {
          this.set(key, value, handleResult.bind(null, key, value));
        }
      }
      if ( total == 0 ) {
        res.end(`<!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta http-equiv="refresh" content="0; url=${base}" />
            </head>
            <body>
              刷新中.....
            </body>
          </html>
        `);
      }
    }
    else {
      var items = this.getAll();
      var rows = [];
      var index = 0;
      var cpus = os.cpus();
      var sysinfo = cpus.length+'核 '+cpus[0].model;
      rows.push(`<tr><td nowrap>CPU信息</td>
        <td>
          ${sysinfo}
        </td></tr>`);
      var totalMem = os.totalmem()/(1024*1024*1024);
      rows.push(`<tr><td nowrap>物理内存</td>
          <td>
            ${totalMem}G
          </td></tr>`);
      var freeMem = (os.freemem()/(1024*1024*1024)).toFixed(3);
      rows.push(`<tr><td nowrap>可用内存</td>
          <td>
            ${freeMem}G
          </td></tr>`);
      for ( var key in this.config ) {
        index ++;
        var rowId = 'row'+index;
        var item = this.config[key];
        var meta = item.meta;
        if ( meta ) {
          var label = meta.label? `${meta.label}(${key})` :key;
          if ( meta.type == 'enum' ){
            var options = meta.options;
            var opts = [];
            options.forEach(function(opt){
              opts.push(`<label><input type="radio" name="${key}" value="${opt.value}" ${item.value==opt.value?'checked':''} />${opt.label}</label>`)
            });
            rows.push(`<tr><td nowrap>${label}</td>
              <td>
                ${opts.join('&nbsp;')}
              </td></tr>`);
          }
          else if ( meta.type == 'bool' ) {
            rows.push(`<tr><td nowrap>${label}</td>
              <td>
                <label><input type="radio" name="${key}" value="true" ${item.value?'checked':''} id="${rowId}"/>启用</label>
                <label><input type="radio" name="${key}" value="false" ${item.value?'':'checked'}/>禁用</label>
              </td></tr>`)
          }
          else if ( meta.type == 'number' || meta.type == 'int' || meta.type == 'long' ){
            rows.push(`<tr><td nowrap><label for="${rowId}">${label}</label></td>
              <td><input name="${key}" value="${item.value}" type="number" id="${rowId}"/></td></tr>`);
          }
          else if ( meta.type == 'string' || meta.type == 'text' ){
            rows.push(`<tr><td nowrap><label for="${rowId}">${label}</label></td>
              <td><input name="${key}" value="${item.value}" id="${rowId}"/></td></tr>`);
          }
          else {
            rows.push(`<tr><td nowrap><label for="${rowId}">${label}</label></td>
              <td><b>${item.value}</b></td></tr>`);
          }
        }
        else {
          rows.push(`<tr><td nowrap>${key}</td><td>${item.value}</td></tr>`);
        }
      }
      rows.push(`<tr><td colspan=2 align="center"><button type="submit">提交</button></td></tr>`)
      var rowsHTML = rows.join('\n');
      res.end(`<!DOCTYPE html>
        <html>
        <head>
          <meta charset='utf-8'>
        </head>
        <body>
          <form method="GET" action="${base}set">
            <div style="width:100%">
              <table style="width:50%;margin:0 auto;">
                <tr>
                  <td>名称</td><td width="80%" align="left">取值</td>
                </tr>
              ${rowsHTML}
              </table>
            </div>
          </form>
        </body>`);
    }
  }
};

Runtime.RedisAdapter = require('./RedisAdapter');
Runtime.prototype.registerConst = Runtime.prototype.registerConstant;
module.exports = Runtime;
