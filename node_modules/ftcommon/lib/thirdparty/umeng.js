'use strict';
var co = require('co');
var request = require('request');
var crypto = require('crypto');
var thunkify = require('thunkify');
var async = require('async');
var PUSH_URL = 'http://msg.umeng.com/api/send';
var runtime = null;

var UMENG_CONFIG = {
  android: {
    appKey: '5566b32267e58e4a05003c02',
    msgKey: '752943631b1d53ad594326e3cf345c76',
    masterKey: 'wnslbzhtnchsnp3gfh7p81ocruwj5mc1'
  },
  ios: {
    appKey: '5566b3a567e58e8571008b9a',
    masterKey: 'bjznatzgidvwtiywenwfxgskojdcicmd'
  }
};

function addCommonParams(params, args){
  function dateToString(d){
    if ( d instanceof Date ) {
      return d.format('yyyy-MM-dd hh:mm:ss');
    }
    else {
      return d;
    }
  }
  if ( !params.policy ) params.policy = {};
  if ( args.start ){
    params.policy.start_time = dateToString(args.start);
  }
  if ( args.expire ) {
    params.policy.expire_time = dateToString(args.expire);
  }
  if ( args.pushId ) {
    params.thirdparty_id = args.pushId;
  }
  var isDebug = runtime?runtime.get('umeng.debug'):args.debug;
  params.production_mode = isDebug?"false":"true";
  if ( args.title ) params.description = args.title;
  params.type = args.group?'groupcast':'broadcast';
  if ( args.group ) {
    params.filter = {
      "where":
      {
        "and": [{"tag": args.group}]
      }
    };
  }
  params.timestamp = args.timestamp?args.timestamp:new Date().getTime();
}

function sign(body, secret){
  //console.log('secret', secret);
  var method='POST';
  var url = PUSH_URL;
  var md5 = crypto.createHash('md5');
  md5.update(method);
  md5.update(url);
  md5.update(body,'utf8');
  md5.update(secret);
  console.log(method,url,body,secret);
  return md5.digest('hex') ;
}

function* sendRequest(url, params, masterKey){
  var body = JSON.stringify(params);
  var sig = sign(body, masterKey);
  var url = url+'?sign='+sig;

  var val = yield thunkify(request.post.bind(request))({url: url, body: body});

  var ret = JSON.parse(val[1]);

  if ( ret && ret.ret === 'SUCCESS' ) {
    console.log(ret.data);
    return ret.data;
  }
  else {
    console.error('sendPushMessage failed with response', ret);
    throw new Error(ret.data.error_code);
  }
}

function sendIOSPushMessage(args, fn){
  co(function*(){
    var payload = {
      aps: {
        sound: 'default'
      }
    };
    var body = payload.aps;
    if ( args.message ) body['alert'] = args.message;
    var msg = '';
    if ( args.title ) {
      msg += args.title;
    }
    if ( args.body ){
      msg += '\n'+args.body;
    }
    if ( msg ) body.alert = msg;
    if ( args.extra ){
      for (var key in args.extra ) {
        var value = args.extra[key];
        body[key] = value;
      }
    }
    var params = {
      appkey: UMENG_CONFIG.ios.appKey,
      payload: payload
    };
    addCommonParams(params, args);
    var ret = yield sendRequest(PUSH_URL, params,  UMENG_CONFIG.ios.masterKey);
    fn(null, ret);
  }).catch(fn);
}

function sendAndroidPushMessage(args, fn){
  co(function*(){
    var payload = {
      'display_type': 'notification'
    };
    payload.body =  {
      ticker: args.title,
      title: args.title,
      text: args.body,
      after_open: 'app',
      sound: 'default'
    };
    var body = payload.body;
    if ( args.extra ) payload.extra = args.extra;
    else payload.extra = {};
    var params = {
      appkey: UMENG_CONFIG.android.appKey,
      payload: payload
    };
    addCommonParams(params, args);
    var ret = yield sendRequest(PUSH_URL, params,  UMENG_CONFIG.android.masterKey);
    fn(null, ret);
  }).catch(fn);
}

exports.push = function(args, fn)
{
  var funcs = {};
  var toAndroid = runtime?runtime.get('umeng.android'):!args.noAndroid;
  if ( toAndroid ) {
    funcs.android = function(next){
      sendAndroidPushMessage(args, next);
    };
  }
  var toIOS = runtime?runtime.get('umeng.ios'):!args.noIOS;
  if ( toIOS) {
    funcs.ios = function(next){
      sendIOSPushMessage(args, next);
    };
  }
  async.parallel(funcs, function(err, results){
    if ( err ) return fn(err);
    else fn( null, results );
  });
}

exports.setRuntime = function(args){
  runtime = args;
}
